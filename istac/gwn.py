#!/usr/bin/env python -3
# encoding: utf-8

#Created by gic on Mon Nov  8 15:27:15 CST 2010

# Copyright (C) 2010 Graham I Cummins
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA
#
from __future__ import print_function, unicode_literals
import numpy as np
import gicdat.doc as gd
import os
import rand

STIMFILE = "istacpaperstim.gic"
STIMFILE = os.path.join(os.path.split(__file__)[0], STIMFILE)
BANDLIMIT = (5,150)
SEED = 12345
FS = 1000
STIMD = None

def uskew(sd=4, skew=5, npts=90):
	x = np.linspace(-5,5, npts)
	y = np.exp(-x**2/(sd*2.0))
	x2 = np.linspace(0, skew, npts)
	x2 = x2 - x2.min()
	m = np.exp(x2)
	y = y*m
	return y/y.max()

def spectrum(signal, fs=FS):
	'''
	Signal is a 1D array representing a time series. fs is the sampling rate of
	this series (in Hz). Return is an Nx2 array where N =  int((fs/2)+1). It
	contains the fourier spectrum of signal, with rows corresponding to
	frequency, at 1 sample per Hz. The first column is the amplitude, and the
	second the phase (in radians).

	The mean is removed from the signal, so the value at index 0 in the
	returned array is not usefull

	'''
	ft = np.fft.rfft(signal - signal.mean(), fs)
	amp = np.abs(ft)*(2.0/fs)
	phase = np.arctan2(ft.imag, ft.real)
	return np.column_stack([amp, phase])

def bandpass(dat, bmin, bmax):
	'''
	dat should be a 1D array. bmin and bmax are float numbers specifying the
	band limit in normalized frequency units (that is units of pi
	radians/sample. Convesion from Hz to normalized frequency is NF =
	Hz/(Fs/2), where Fs is the sampling rate of the input)	 
	
	Return value is a 1D array like dat, that has been bandpass filtered.
	'''
	n = max(90, int(4.0/(bmax-bmin)))
	if n%2:
		n+=1
	r=np.arange((n/2)+1)
	ideal=np.greater_equal(r, bmin*(n/2))*np.less_equal(r,bmax*(n/2))
	return bandshape(dat, ideal)

def bandshape(dat, ideal):
	n = 2*(ideal.shape[0]-1)
	rft=np.fft.irfft(ideal)
	rft=np.concatenate((rft[n/2:], rft[:n/2+1]))
	n = rft.size
	w=0.54-0.46*np.cos(2*np.pi*np.arange(n)/(n-1))
	f = w*rft
	f = f[::-1]  #reverse elements using extended slice notation
	z=np.concatenate([np.zeros_like(f),  dat, np.zeros_like(f)])
	z=np.convolve(z, f, str('same'))
	z=z[f.size-1:f.size+dat.size-1]
	return z


def gwn(l, band=None, fs=FS, retraw=False):
	'''
	Generate band limit Gaussian white noise
	l is the length of the sequence, in seconds. Band is a tuple (low, high)
	specifying the bounds of the pass band, in Hz. Band may also be None, for
	no band limit. fs is the desired sampling rate (in Hz). The return value is
	a 1D array of length l*fs.
	
	Band may also be "pink" or "blue". In this case the band filter used is 
	generated by uskew with up=True ('blue') or False ('pink')

	If 'seed' is specified, it is passed to numpy.random.seed. This value
	allows the production of reproducible (frozen) noise. The default value of
	seed (None) will result in different sequences on each call

	'''
	ns = int(round(l*fs))
	wn = rand.stimulus(ns)
	if not band:
		return wn
	else:
		if len(band) == 3:
			ideal = apply(uskew, band)
			blwn = bandshape(wn, ideal)
		else:
			blwn = bandpass(wn, band[0]/(fs/2.0), band[1]/(fs/2.0))
		if retraw:
			return (blwn, wn)
		else:
			return blwn

def getstim(what = 'doc', l=800, band=BANDLIMIT):
	'''
	what is <'doc'|'raw'|'bl'>. Returns <gicdat.doc.Doc instance |
	array(N,real)>. Generates and returns a consitant stimulus.
	If what=='doc', return the gicdat
	document from the file. If what == 'raw', return the second channel of
	doc['stimulus'].data, which contains non-band-passed gaussian white noise.
	If what == 'bl', return the first channel (which is band passed to
	BANDLIMIT)

	'''
	(sbl, sraw) = gwn(l, band, FS, True)
	if what == 'raw':
		return sraw
	elif what == 'bl':
		return sbl
	else:
		doc = gd.Doc()
		ns = 'stim%i_%i' % band
		doc[ns] = sbl
		doc[ns + '.raw'] = sraw
		doc[ns + '.tag'] = 'timeseries'
		doc[ns + '.samplerate'] = 1000.0
		doc.set('start', 0, ns=ns) 
		return doc

